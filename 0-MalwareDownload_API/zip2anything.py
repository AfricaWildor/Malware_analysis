# -*- codeing = utf-8 -*-

import os
import re
import zipfile  # 用于对zip压缩包的操作
from zipfile import ZipFile
import pyzipper
from pyzipper import AESZipFile
import pefile
from capstone import *


def bytes2hexStr(bytes):
	hexStr = bytes.hex()
	return hexStr


def pe_view(filepath):
	pe = pefile.PE(filepath)
	print(pe)
	Flags = pe.dump_dict()['Flags']
	asm_bit = pe.FILE_HEADER.Machine
	print(asm_bit)
	print()
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			print(section.get_data())



def text_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			# print(section)
			return section.get_data()


def section_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	sections_bytes = bytearray(b'')
	for section in pe.sections:
		sections_bytes.extend(section.get_data())
	return sections_bytes


def bytes2bytesFile(filebytes, filename):
	if filebytes is None:
		print('[!] Error, no bytes found')
		return
	hexStr = bytes2hexStr(filebytes)
	# print(hexStr)
	# 每2个为一组
	hexlist = re.findall(r'.{2}', hexStr)
	# print(hexlist)
	content = ''
	length = len(hexlist)
	flag = 1
	for hex in range(0, length):
		if flag == 16:
			flag = 0
			content += f'{hexlist[hex]}\r\n'
		else:
			content += f'{hexlist[hex]} '
		if hex == length - 1:
			content += f'{hexlist[hex]}'
		flag += 1
	# print(f'Convert {filename} to bytes')
	# print(content)
	contentbytes = bytes(content, 'utf-8')
	bytes_filepath = filename.split('.zip')[0] + '.bytes'
	# print(bytes_filepath)

	with open(bytes_filepath, 'wb') as file:
		file.write(contentbytes)
		print(f'write in {bytes_filepath}')


def bytes2AsmCode(filebytes):
	code = filebytes
	print(filebytes)
	mode = Cs(CS_ARCH_X86, CS_MODE_32)
	for i in mode.disasm(code, 0x1000):
		print("0x%x:\t%s\t%s" % (i.address, i.mnemonic, i.op_str))



# 找程序代码所在的节
def get_text_section(pe):
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			return section

def pe_32bit_check(pe):
	asm_bit = pe.FILE_HEADER.Machine
	if asm_bit == 0x014c:
		print('Disasm Mode:CS_MODE_32')
		return CS_MODE_32
	else:
		print('Disasm Mode:CS_MODE_64')
		return CS_MODE_64

def exe2asm_code(filebytes):

	pe = pefile.PE(data=filebytes)
	# pe = pefile.PE(filebytes)

	text_section=get_text_section(pe)
	# if there's no .text,return
	if text_section is None:
		print('[!] Error, no .text found')
		return ''

	asm_mode= pe_32bit_check(pe)
	# define the disasm mode
	md = Cs(CS_ARCH_X86, asm_mode)
	md.detail = True
	last_address = 0
	last_size = 0
	# Beginning of code section
	begin = text_section.PointerToRawData
	# the end of the code section
	end = begin + text_section.SizeOfRawData
	# print(hex(begin),hex(end))
	asm_code='' #store the op
	# the second arg just give the address offset, no influence to the op
	while True:
		# parse code section and disassemble it
		data = pe.get_memory_mapped_image()[begin:end]
		for i in md.disasm(data, begin):
			asm_code+=(f'{i.mnemonic}\r\n')
			last_address = int(i.address)
			last_size = i.size
		# disasm一次反汇编有个数限制，故需循环多次反汇编，每次的起始翻译地址需循环变动
		begin = max(int(last_address), begin) + last_size + 1
		# 若起始地址大于等于结束地址，则代码段全部翻译
		if begin >= end:
			print("Disasm Finish")
			break
	return asm_code

def bodmas2asm_code(filepath):
	suffix = filepath.split('.')
	suffix=suffix[len(suffix)-1]
	if suffix != 'zip':
		return
	if pyzipper.is_zipfile(filepath):
		zip = AESZipFile(filepath)
		path=filepath.split('.zip')[0]+'\\asm_code\\'
		if not os.path.exists(path):  # 是否存在这个文件夹
			os.makedirs(path)
		if not os.path.exists(path+'altered\\'):  # 是否存在这个文件夹
			os.makedirs(path+'altered\\')

		filelist = zip.namelist()
		print(filelist)
		pwd = b'infected'
		for file in filelist:
			# print(file)
			filename = path + file.split('.exe')[0] +'.asm'

			if os.path.exists(filename):  # 是否存在这个文件夹
				print(f"{filename} asm_code already exists")
				continue
			try:
				filebytes = zip.read(file, pwd)
				try:
					asm_code = (exe2asm_code(filebytes))
					if asm_code == '':
						continue
					# print(asm_code)
				except:
					print('Find asm_code Error')
					continue
				# print(filename)
				with open(filename, 'wb') as file:
					file.write(bytes(asm_code, 'utf-8'))
					print(f'write in {filename}')
			except:
				print(filename+" Trans Error")
				continue
		zip.close()


def zip2bytes(filepath):
	suffix = filepath.split('.')
	suffix=suffix[len(suffix)-1]
	print(suffix)
	if suffix == 'zip':
		if pyzipper.is_zipfile(filepath):
			file = AESZipFile(filepath)
			filelist = file.namelist()
			print(filelist)
			filename = filelist[0]  # 解压文件名
			pwd = b'infected'
			filebytes = file.read(filename, pwd)
			file.close()
			return filebytes
	elif suffix=='exe':
		with open(filepath, 'rb') as file:
			filebytes = file.read()
			file.close()
			return filebytes


def zip2text(filepath):
	filebytes = zip2bytes(filepath)
	try:
		textbytes = text_extract(filebytes)
	except:
		return
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)


def bodmas2bytesfiles(filepath):
	suffix = filepath.split('.')
	suffix=suffix[len(suffix)-1]
	if suffix != 'zip':
		return
	if pyzipper.is_zipfile(filepath):
		zip = AESZipFile(filepath)
		path=filepath.split('.zip')[0]+'\\bytesfile\\'
		if not os.path.exists(path):  # 是否存在这个文件夹
			os.makedirs(path)
		if not os.path.exists(path+'altered\\'):  # 是否存在这个文件夹
			os.makedirs(path+'altered\\')

		filelist = zip.namelist()
		print(filelist)
		pwd = b'infected'
		for file in filelist:
			# print(file)
			filename = path + file.split('.exe')[0]

			if os.path.exists(filename+'.bytes'):  # 是否存在这个文件夹
				print(f"{filename} bytesfile already exists")
				continue
			try:
				filebytes = zip.read(file, pwd)
				try:
					textbytes = section_extract(filebytes)
				except:
					print('Find Section Error')
					continue
				# print(filename)
				bytes2bytesFile(textbytes,f'{filename}.zip')
			except:
				print(filename+" Trans Error")
				continue
		zip.close()



def zip2sections(filepath):
	filebytes = zip2bytes(filepath)
	try:
		textbytes = section_extract(filebytes)
	except:
		return
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)

def zip2asmcode(filepath):
	filebytes = zip2bytes(filepath)
	asm_code=(exe2asm_code(filebytes))
	if asm_code=='':
		return
	# print(asm_code)

	bytes_filepath = filepath.split('.zip')[0] + '.asm'
	with open(bytes_filepath, 'wb') as file:
		file.write(bytes(asm_code,'utf-8'))
		print(f'write in {bytes_filepath}')

	# 是否删除原zip文件
	# os.remove(filepath)



def zip2anything(filepath):
	filebytes = zip2bytes(filepath)
	bytes2AsmCode(filebytes)






if __name__ == '__main__':
	# PEfile_Path = "sample/notextsample.zip"
	# zip2asmcode(PEfile_Path)

	# p='D:\\PythonProject\\python\\pythonProject\\Malware_analysis\\0-MalwareDownload_API\\sample\\1a6955d26907b3c83f10ede259494ff2d68ab210e1090cb6806e05d1dca36869.zip'
	# with open(p, 'wb') as file:
	# 	print('1')

	zip_path='sample/sample.zip'
	bodmas2bytesfiles(zip_path)


	# exe2asm_code(PEfile_Path)
	# pe_view(PEfile_Path)
