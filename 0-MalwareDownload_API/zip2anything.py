# -*- codeing = utf-8 -*-

import os
import re
import zipfile  # 用于对zip压缩包的操作
from zipfile import ZipFile
import pyzipper
from pyzipper import AESZipFile
import pefile
from capstone import *


def bytes2hexStr(bytes):
	hexStr = bytes.hex()
	return hexStr


def pe_view(filepath):
	pe = pefile.PE(filepath)
	print(pe)
	Flags = pe.dump_dict()['Flags']
	asm_bit = pe.FILE_HEADER.Machine
	print(asm_bit)
	print()
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			print(section.get_data())



def text_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			# print(section)
			return section.get_data()


def section_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	sections_bytes = bytearray(b'')
	for section in pe.sections:
		sections_bytes.extend(section.get_data())
	return sections_bytes


def bytes2bytesFile(filebytes, filename):
	if filebytes is None:
		print('[!] Error, no bytes found')
		return
	hexStr = bytes2hexStr(filebytes)
	# print(hexStr)
	# 每2个为一组
	hexlist = re.findall(r'.{2}', hexStr)
	# print(hexlist)
	content = ''
	length = len(hexlist)
	flag = 1
	for hex in range(0, length):
		if flag == 16:
			flag = 0
			content += f'{hexlist[hex]}\r\n'
		else:
			content += f'{hexlist[hex]} '
		if hex == length - 1:
			content += f'{hexlist[hex]}'
		flag += 1
	# print(f'Convert {filename} to bytes')
	# print(content)
	contentbytes = bytes(content, 'utf-8')
	bytes_filepath = filename.split('.zip')[0] + '.bytes'

	with open(bytes_filepath, 'wb') as file:
		file.write(contentbytes)
		print(f'write in {bytes_filepath}')


def bytes2AsmCode(filebytes):
	code = filebytes
	print(filebytes)
	mode = Cs(CS_ARCH_X86, CS_MODE_32)
	for i in mode.disasm(code, 0x1000):
		print("0x%x:\t%s\t%s" % (i.address, i.mnemonic, i.op_str))


# ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
# ep_ava = ep + pe.OPTIONAL_HEADER.ImageBase
# data = pe.get_memory_mapped_image()[ep:ep + 100]
# offset = 0
# while offset < len(data):
# 	i = pydasm.get_instruction(data[offset:], pydasm.MODE_32)
# 	print(pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava + offset))

# 找程序代码所在的节
def get_text_section(pe):
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			return section

def pe_32bit_determine(pe):
	asm_bit = pe.FILE_HEADER.Machine
	if asm_bit == 0x014c:
		return CS_MODE_32
	else:
		return CS_MODE_64

def exe2asm_code(filebytes):
	pe = pefile.PE(data=filebytes)
	text_section=get_text_section(pe)
	asm_mode=pe_32bit_determine(pe)

	# define the disasm mode
	md = Cs(CS_ARCH_X86, asm_mode)
	md.detail = True
	last_address = 0
	last_size = 0
	# Beginning of code section
	begin = text_section.PointerToRawData
	# the end of the code section
	end = begin + text_section.SizeOfRawData
	while True:
		# parse code section and disassemble it
		data = pe.get_memory_mapped_image()[begin:end]
		for i in md.disasm(data, begin):
			print(i)
			last_address = int(i.address)
			last_size = i.size
		# sometimes you need to skip some bytes
		begin = max(int(last_address), begin) + last_size + 1
		if begin >= end:
			print("out")
			break


def zip2bytes(filepath):
	if pyzipper.is_zipfile(filepath):
		file = AESZipFile(filepath)
		filelist = file.namelist()
		print(filelist)
		filename = filelist[0]  # 解压文件名
		pwd = b'infected'
		filebytes = file.read(filename, pwd)
		file.close()
		return filebytes


def zip2text(filepath):
	filebytes = zip2bytes(filepath)
	textbytes = text_extract(filebytes)
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)



def zip2sections(filepath):
	filebytes = zip2bytes(filepath)
	textbytes = section_extract(filebytes)
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)

def zip2asmcode(filepath):
	filebytes = zip2bytes(filepath)
	exe2asm_code(filebytes)




def zip2anything(filepath):
	filebytes = zip2bytes(filepath)
	bytes2AsmCode(filebytes)


# 是否删除原zip文件
# os.remove(filepath)


if __name__ == '__main__':
	PEfile_Path = "sample/overflow_exe.zip"
	# fine_disassemble(PEfile_Path)
	zip2asmcode(PEfile_Path)

# pe_view(PEfile_Path)
# with open(PEfile_Path, 'rb') as file:
# 	filebytes=file.read()
