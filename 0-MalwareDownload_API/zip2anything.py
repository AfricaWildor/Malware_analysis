# -*- codeing = utf-8 -*-

import os
import re
import zipfile  # 用于对zip压缩包的操作
from zipfile import ZipFile
import pyzipper
from pyzipper import AESZipFile
import pefile
from capstone import *


def bytes2hexStr(bytes):
	hexStr = bytes.hex()
	return hexStr


def pe_view(filepath):
	pe = pefile.PE(filepath)
	print(pe)
	Flags = pe.dump_dict()['Flags']
	asm_bit = pe.FILE_HEADER.Machine
	print(asm_bit)
	print()
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			print(section.get_data())



def text_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			# print(section)
			return section.get_data()


def section_extract(filebytes):
	pe = pefile.PE(data=filebytes)
	sections_bytes = bytearray(b'')
	for section in pe.sections:
		sections_bytes.extend(section.get_data())
	return sections_bytes


def bytes2bytesFile(filebytes, filename):
	if filebytes is None:
		print('[!] Error, no bytes found')
		return
	hexStr = bytes2hexStr(filebytes)
	# print(hexStr)
	# 每2个为一组
	hexlist = re.findall(r'.{2}', hexStr)
	# print(hexlist)
	content = ''
	length = len(hexlist)
	flag = 1
	for hex in range(0, length):
		if flag == 16:
			flag = 0
			content += f'{hexlist[hex]}\r\n'
		else:
			content += f'{hexlist[hex]} '
		if hex == length - 1:
			content += f'{hexlist[hex]}'
		flag += 1
	# print(f'Convert {filename} to bytes')
	# print(content)
	contentbytes = bytes(content, 'utf-8')
	bytes_filepath = filename.split('.zip')[0] + '.bytes'

	with open(bytes_filepath, 'wb') as file:
		file.write(contentbytes)
		print(f'write in {bytes_filepath}')


def bytes2AsmCode(filebytes):
	code = filebytes
	print(filebytes)
	mode = Cs(CS_ARCH_X86, CS_MODE_32)
	for i in mode.disasm(code, 0x1000):
		print("0x%x:\t%s\t%s" % (i.address, i.mnemonic, i.op_str))



# 找程序代码所在的节
def get_text_section(pe):
	for section in pe.sections:
		if section.Name.startswith(b'.text\x00'):
			return section

def pe_32bit_determine(pe):
	asm_bit = pe.FILE_HEADER.Machine
	if asm_bit == 0x014c:
		print('Disasm Mode:CS_MODE_32')
		return CS_MODE_32
	else:
		print('Disasm Mode:CS_MODE_64')
		return CS_MODE_64

def exe2asm_code(filebytes):

	pe = pefile.PE(data=filebytes)
	# pe = pefile.PE(filebytes)

	text_section=get_text_section(pe)
	asm_mode=pe_32bit_determine(pe)

	# define the disasm mode
	md = Cs(CS_ARCH_X86, asm_mode)
	md.detail = True
	last_address = 0
	last_size = 0
	# Beginning of code section
	begin = text_section.PointerToRawData
	# the end of the code section
	end = begin + text_section.SizeOfRawData
	print(hex(begin),hex(end))
	asm_code='' #store the op
	# the second arg just give the address offset, no influence to the op
	while True:
		# parse code section and disassemble it
		data = pe.get_memory_mapped_image()[begin:end]
		for i in md.disasm(data, begin):
			# print(i)
			# print(hex(i.address))# 地址
			# print(i.size)# 字节数
			# print(i.op_str)  # 操作数
			# print(i.mnemonic)# 操作码

			asm_code+=(f'{i.mnemonic}\r\n')
			last_address = int(i.address)
			last_size = i.size
		# disasm一次反汇编有个数限制，故需循环多次反汇编，每次的起始翻译地址需循环变动
		begin = max(int(last_address), begin) + last_size + 1
		# 若起始地址大于等于结束地址，则代码段全部翻译
		if begin >= end:
			print("Disasm Finish")
			break
	return asm_code

def zip2bytes(filepath):
	if pyzipper.is_zipfile(filepath):
		file = AESZipFile(filepath)
		filelist = file.namelist()
		print(filelist)
		filename = filelist[0]  # 解压文件名
		pwd = b'infected'
		filebytes = file.read(filename, pwd)
		file.close()
		return filebytes


def zip2text(filepath):
	filebytes = zip2bytes(filepath)
	textbytes = text_extract(filebytes)
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)



def zip2sections(filepath):
	filebytes = zip2bytes(filepath)
	textbytes = section_extract(filebytes)
	bytes2bytesFile(textbytes, filepath)
	# 是否删除原zip文件
	# os.remove(filepath)

def zip2asmcode(filepath):
	filebytes = zip2bytes(filepath)
	asm_code=(exe2asm_code(filebytes))
	# print(asm_code)

	bytes_filepath = filepath.split('.zip')[0] + '.asm'
	with open(bytes_filepath, 'wb') as file:
		file.write(bytes(asm_code,'utf-8'))
		print(f'write in {bytes_filepath}')

	# 是否删除原zip文件
	# os.remove(filepath)



def zip2anything(filepath):
	filebytes = zip2bytes(filepath)
	bytes2AsmCode(filebytes)





if __name__ == '__main__':
	PEfile_Path = "sample/njrat2.zip"
	zip2asmcode(PEfile_Path)

	# exe2asm_code(PEfile_Path)
	# pe_view(PEfile_Path)
