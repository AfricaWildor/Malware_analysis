import numpy as np


class LogisticRegression:
	def __init__(self, train_data, alpha=0.001, circle=1000, batch_length=40):
		self.train_data = train_data  # 训练数据集
		self.alpha = alpha  # 学习率
		self.circle = circle  # 学习次数
		self.batch_length = batch_length  # 把3349个数据分成多个部分，每个部分有batch_length个数据
		self.w = np.random.normal(size=(2, 1))  # 随机初始化参数w

	def data_process(self):
		'''做随机梯度下降，打乱数据顺序，并把所有数据分成若干个batch'''
		np.random.shuffle(self.train_data)
		data = [self.train_data[i:i + self.batch_length]
				for i in range(0, len(self.train_data), self.batch_length)]
		return data

	def train(self):
		''' 根据损失函数（1）来进行梯度下降，这里采用随机梯度下降 '''
		for i in range(self.circle):
			batches = self.data_process()
			print('the {} epoch'.format(i))  # 程序运行时显示执行次数
			for batch in batches:
				d_w = np.zeros(shape=(2, 1))  # 用来累计w导数值
				for j in batch:  # 取batch中每一组数据
					x0 = np.r_[j[0], 1]  # 把数据中指标取出，后面补1
					x = np.mat(x0).T  # 转化成列向量
					y = j[1]  # 标签
					dw = (self.sigmoid(self.w.T * x) - y)[0, 0] * x
					d_w += dw
				self.w -= self.alpha * d_w / self.batch_length

	def train2(self):
		'''用均方损失函数来进行梯度下降求解'''
		for i in range(self.circle):
			batches = self.data_process()
			print('the {} epoch'.format(i))  # 程序运行时显示执行次数
			for batch in batches:
				d_w = np.zeros(shape=(2, 1))  # 用来累计w导数值
				for j in batch:  # 取batch中每一组数据
					x0 = np.r_[j[0], 1]  # 把数据中指标取出，后面补1
					x = np.mat(x0).T  # 转化成列向量
					y = j[1]  # 标签
					dw = ((self.sigmoid(self.w.T * x) - y) * self.sigmoid(self.w.T * x) * (1 - self.sigmoid(self.w.T * x)))[0, 0] * x
					d_w += dw
				self.w -= self.alpha * d_w / self.batch_length


	def sigmoid(self, x):
		return 1 / (1 + np.exp(-x))

	def predict(self, j):
		'''测试新数据属于哪一类，x是2维列向量'''
		x0 = np.r_[j[0], 1]  # 把数据中指标取出，后面补1
		x = np.mat(x0).T  # 转化成列向量
		s = self.sigmoid(self.w.T * x)
		predict_res = 0
		if s >= 0.5:
			predict_res = 1
		elif s < 0.5:
			predict_res = 0
		if j[1] == predict_res:
			return True
		else:
			return False

	def get_result(self):
		res = -(self.w[1]) / self.w[0]
		print(f'w: {self.w[0]}, b: {self.w[1]}, res: {res}')


if __name__ == '__main__':
	origin_data = np.load('10th_irrelevant_samples.npy')
	data = []
	labs = []
	for i in origin_data:
		label = int(i[10])
		if label != 9:
			data.append(i[label])
			labs.append(1)
		else:
			for j in range(9):
				data.append(i[j])
				labs.append(0)

	# data = [1] * 1000
	# labs = [1] * 1000
	#
	# d = [-100] * 1000
	# l1 = [0] * 1000
	# data += d
	# labs += l1

	train_data = list(zip(data, labs))
	print(train_data)
	lr = LogisticRegression(train_data=train_data)
	lr.train()
	lr.get_result()
