def bin2image(content, resize=True):
    """
    binary to gray image
    """
    width = imagesize(len(content))
    fh = np.frombuffer(content, dtype=np.uint8)
    rn = len(fh)/width
    fh = np.reshape(fh[:int(rn)*width],(int(rn),width))

    im = Image.fromarray(fh)
    if resize:
        im = im.resize((244,244))
    return im

def H(data):
    ''' Calculate the entropy of a given data block '''
    c = np.bincount(data, minlength=256) 
    p = c.astype(np.float32) / len(data)
    wh = np.where(c)[0]
    H = np.sum(-p[wh] * np.log2(
        p[wh]))
    return H

def block_entropy(data, window=1024, step=256):
    Hbins = []
    if data.shape[0] < window:
        Hbin = H(data)
        Hbins.append(Hbin)
    else:
        shape = data.shape[:-1] + (data.shape[-1] - window + 1, window)
        strides = data.strides + (data.strides[-1],)
        blocks = np.lib.stride_tricks.as_strided(data, shape=shape, strides=strides)[::step, :]

        for block in blocks:
            Hbin = H(block)
            Hbins.append(Hbin)
    return Hbins

def bin2entropy(content, block_size=1024, step=256, resize=True):
    """
    following resources: https://github.com/gcmartinelli/entroPy/blob/master/entropy.py
    but fatser 6x time
    """
    data = np.frombuffer(content, dtype=np.uint8)
    entropy_list = block_entropy(data, block_size, step)
    width = imagesize(len(entropy_list))*2
    rn = len(entropy_list)/width
    matrix = np.reshape(entropy_list[:int(rn)*width],(int(rn),width)) 
    im = Image.fromarray(matrix * 255/8)
    if resize:
        im = im.resize((244,244))
    return im
