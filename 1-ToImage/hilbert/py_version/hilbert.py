import numpy as np


class HilbertCurve:
	init_mat: np.ndarray
	n: int

	def __init__(self, n: int):
		self.n = n
		self.get()

	def marshel(self):
		np.save("./hilbert", self.init_mat)

	def show(self):
		l = len(self.init_mat)
		for x in range(l):
			print(self.init_mat[x])

	def get(self):
		init_arr = np.array([[1, 2], [0, 3]])
		n = self.n
		while n > 1:
			n = n - 1
			init_arr = self.up(init_arr)

		self.init_mat = np.flipud(init_arr)
		return init_arr

	@staticmethod
	def transposition(arr, key: bool):
		l = len(arr)
		matrix = np.zeros((l, l), dtype=int)
		for i in range(l):
			for j in range(l):
				if key:
					t = arr[l - 1 - i][l - 1 - j]
					matrix[j][i] = t
				else:
					matrix[j][i] = arr[i][j]
		return matrix

	@staticmethod
	def up(arr):
		l = len(arr)
		n = 0
		while 1 << n < l:
			n = n + 1
		value = 4 ** n
		matrix = np.zeros((2*l, 2*l), dtype=int)

		three = HilbertCurve.transposition(arr, True)
		for i in range(l):
			for j in range(l):
				matrix[i + l][j] = three[i][j]

		four = HilbertCurve.transposition(arr, False)
		for i in range(l):
			for j in range(l):
				matrix[i + l][j + l] = four[i][j] + 3 * value

		one = arr
		for i in range(l):
			for j in range(l):
				matrix[i][j + l] = one[i][j] + 2 * value

		two = arr
		for i in range(l):
			for j in range(l):
				matrix[i][j] = two[i][j] + value

		return matrix

