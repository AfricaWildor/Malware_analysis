package hilbertcurve

import (
	"fmt"
	"math"

	"gonum.org/v1/gonum/mat"
)

type HilbertCurve struct {
	Rank int
	Order  int
	matrix *mat.Dense
}


func (h *HilbertCurve) At(i, j int) int {
	if i < h.Order && j < h.Order {
		return int(h.matrix.At(i, j))
	} else {
		return 0
	}
}


func New(rank int) *HilbertCurve {
	return new(HilbertCurve).init(rank)
}

func (h *HilbertCurve) init(r int) *HilbertCurve {
	h.Rank = r
	h.Order = int(math.Pow(2, float64(r)))
	d := mat.NewDense(2, 2, []float64{
		1, 2,
		0, 3,
	})

	for r > 1 {
		r--
		d = h.up(d)
	}
	
	m := mat.NewDense(h.Order, h.Order, nil)

	for i := 0; i < h.Order; i++ {
		for j := 0; j < h.Order; j++ {
			m.Set(i, j, d.At(h.Order - i - 1, j))
		}
	}

	h.matrix = m
	return h
}

func (h *HilbertCurve) up(d *mat.Dense) *mat.Dense {
	l, _ := d.Dims()
	n := 0
	for 1 << n < l {
		n = n + 1
	}
	value := math.Pow(4, float64(n))
	matrix := mat.NewDense(2*l, 2*l, nil)

	three := h.transposition(d, true)
	for i := 0; i < l; i++ {
		for j := 0; j < l; j++ {
			matrix.Set(i+l, j, three.At(i, j))
		}
	}

	four := h.transposition(d, false)
	for i := 0; i < l; i++ {
		for j := 0; j < l; j++ {
			matrix.Set(i+l, j+l, four.At(i, j) + 3 * value)
		}
	}

	for i := 0; i < l; i++ {
		for j := 0; j < l; j++ {
			matrix.Set(i, j+l, d.At(i, j) + 2 * value)
		}
	}

	for i := 0; i < l; i++ {
		for j := 0; j < l; j++ {
			matrix.Set(i, j, d.At(i, j) + value)
		}
	}

	return matrix
}

func (h *HilbertCurve) transposition(d *mat.Dense, key bool) *mat.Dense {
	l, _ := d.Dims()
	matrix := mat.NewDense(l, l, nil)
	for i := 0; i < l; i++ {
		for j := 0; j < l; j++ {
			if key {
				matrix.Set(j, i, d.At(l-1-i, l-1-j))
			} else {
				matrix.Set(j, i, d.At(i, j))
			}
		}
	}
	return matrix
}

func (h *HilbertCurve) Formatted() fmt.Formatter {
	return mat.Formatted(h.matrix)
}