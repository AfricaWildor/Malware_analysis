import csv
import math
import os
import array
import numpy as np
from PIL import Image, ImageDraw

class_map = {}

with open("D:/academy/AcaUni/实验班/网安分析实践/trainLabels.csv") as f:
	fcsv = csv.DictReader(f)
	for row in fcsv:
		class_map[row["Id"]] = row["Class"]


# 生成指定大小滑动窗口的香农熵
def entropy_map(file_bytes, sliding_window):
	d = int(len(file_bytes) / sliding_window)
	m = []
	for i in range(d):
		base = i * sliding_window
		window = file_bytes[base:base + sliding_window]
		count = {}  # 空字典
		for j in window:
			count[j] = count.get(j, 0) + (1 / len(window))
		entro = []
		for a in count.values():
			entro.append(a)
		result = 0
		for x in entro:
			result += (-x) * math.log(x, 2)
		for j in range(sliding_window):
			m.append(int(result * 32))
	return m


# 生成基于2-gram的马尔科夫概率矩阵
def markov_matrix(file_bytes):
	buffer = array.array('B', file_bytes)

	array1 = np.zeros((256, 256), dtype=int)
	for i in range(len(buffer) - 2):
		j = i + 1
		array1[buffer[i]][buffer[j]] += 1

	turn_array = np.zeros(256, dtype=int)
	for i in range(256):
		for j in range(256):
			turn_array[i] += array1[i][j]

	array2 = np.zeros((256, 256), dtype=int)
	for i in range(256):
		for j in range(256):
			if turn_array[i] != 0:
				array2[i][j] = math.ceil((array1[i][j] / turn_array[i]) * 255) * 32

	return array2


def generate():
	# 初始化
	file_list = os.listdir("E:/malware-classification/set/train")
	# arr = np.load("./hilbert.npy")
	n = 8
	dim = 2 ** n
	num = 0
	# 遍历生成
	for file in file_list:
		if file.find(".bytes") >= 0:
			bytes_list = b''
			line = 0
			# 读文件
			with open(os.path.join("E:/malware-classification/set/train", file), mode="r") as f:
				for l in f:
					if l.find("?") >= 0:
						continue
					str_list = l.split(" ")[1:]
					b = bytes.fromhex("".join(str_list))
					bytes_list += b
					line = line + 1
					if line == 4096:
						break

			if len(bytes_list) == 0:
				print(f"{file} is empty")
				continue

			# 生成基于2-gram的马尔科夫概率矩阵
			mm = markov_matrix(bytes_list)

			# 生成滑动窗口为256个字节的香农熵
			em = entropy_map(bytes_list, 256)

			# print(len(em), len(bytes_list))

			# 绘制RGB图像
			# img = {r: markov, g: origin, b: entropy}
			c = Image.new("RGB", (dim, dim))
			draw = ImageDraw.Draw(c)

			# 绘制hilbert
			# for i in range(dim):
			# 	for j in range(dim):
			# 		# 重复填充
			# 		index = arr[i][j] % len(bytes_list)
			# 		index1 = arr[i][j] % len(em)
			# 		draw.point((i, j), (mm[i][j], bytes_list[index], em[index1]))

			# 绘制原顺序
			for i in range(dim):
				for j in range(dim):
					# 重复填充
					index = (i * 256 + j) % len(bytes_list)
					index1 = (i * 256 + j) % len(em)
					draw.point((i, j), (mm[i][j], bytes_list[index], em[index1]))

			Id = file.split(".")[0]
			Class = class_map[Id]
			c.save(f"D:/academy/temp/rgb_img/{Class}/{file}.png")

			num = num + 1
			print(num)


generate()
