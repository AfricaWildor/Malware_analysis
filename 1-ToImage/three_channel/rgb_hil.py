import math
import os
import array
import numpy as np
from PIL import Image, ImageDraw


# 生成指定大小滑动窗口的香农熵
def entropy_map(file_bytes, sliding_window):
    d = int(len(file_bytes) / sliding_window)
    m = []
    for i in range(d):
        base = i * sliding_window
        window = file_bytes[base:base + sliding_window]
        count = {}  # 空字典
        for j in window:
            count[j] = count.get(j, 0) + (1 / len(window))
        entro = []
        for a in count.values():
            entro.append(a)
        result = 0
        for x in entro:
            result += (-x) * math.log(x, 2)
        for j in range(sliding_window):
            m.append(int(result * 32))
    return m


# 生成基于2-gram的马尔科夫概率矩阵
def markov_matrix(file_bytes):
    buffer = array.array('B', file_bytes)

    array1 = np.zeros((256, 256), dtype=int)
    for i in range(len(buffer) - 2):
        j = i + 1
        array1[buffer[i]][buffer[j]] += 1

    turn_array = np.zeros(256, dtype=int)
    for i in range(256):
        for j in range(256):
            turn_array[i] += array1[i][j]

    array2 = np.zeros((256, 256), dtype=int)
    for i in range(256):
        for j in range(256):
            if turn_array[i] != 0:
                array2[i][j] = math.ceil((array1[i][j] / turn_array[i]) * 255) * 32

    return array2


def generate():
    # 初始化
    file_list = os.listdir("E:/malware-classification/set/train")
    arr = np.load("./hilbert.npy")
    n = 8
    dim = 2 ** n
    num = 0
    # 遍历生成
    for file in file_list:
        if file.find(".bytes") >= 0:
            bytes_list = b''
            line = 0
            # 读文件
            with open(os.path.join("E:/malware-classification/set/train", file), mode="r") as f:
                for l in f:
                    if l.find("?") >= 0:
                        continue
                    str_list = l.split(" ")[1:]
                    b = bytes.fromhex("".join(str_list))
                    bytes_list += b
                    line = line + 1
                    if line == 4096:
                        break

            if len(bytes_list) == 0:
                print(f"{file} is empty")
                continue

            # 生成基于2-gram的马尔科夫概率矩阵
            mm = markov_matrix(bytes_list)

            # 生成滑动窗口为256个字节的香农熵
            em = entropy_map(bytes_list, 256)

            # print(len(em), len(bytes_list))

            # 绘制RGB图像
            # img = {r: markov, g: origin, b: entropy}
            c = Image.new("RGB", (dim, dim))
            draw = ImageDraw.Draw(c)

            for i in range(dim):
                for j in range(dim):
                    # 重复填充
                    index = arr[i][j] % len(bytes_list)
                    index1 = arr[i][j] % len(em)
                    draw.point((i, j), (mm[i][j], bytes_list[index], em[index1]))

            c.save(f"D:/academy/temp/rgb_img/{file}.png")
            num = num + 1
            print(num)


def generate1():
    arr = np.load("./hilbert.npy")
    # print(arr)
    n = 8
    dim = 2 ** n
    num = 0
    dir_list = os.listdir("D:\\academy\\AcaUni\\实验班\网安分析实践\BYTES-DATABASE\BYTES-DATABASE")
    for subDir in dir_list:
        file_list = os.listdir(os.path.join("D:\\academy\AcaUni\实验班\网安分析实践\BYTES-DATABASE\BYTES-DATABASE", subDir))
        for file in file_list:
            # print(file)
            if file.find(".bytes") >= 0:
                bytes_list = b''
                line = 0
                with open(os.path.join("D:\\academy\AcaUni\实验班\网安分析实践\BYTES-DATABASE\BYTES-DATABASE", subDir, file),
                          mode="r") as f:
                    for l in f:
                        if l.find("?") >= 0:
                            continue
                        str_list = l.split(" ")[1:]
                        b = bytes.fromhex("".join(str_list))
                        bytes_list += b
                        line = line + 1
                        if line == 4096:
                            break

                if len(bytes_list) == 0:
                    print(f"{file} is empty")
                    continue

                # 生成基于2-gram的马尔科夫概率矩阵
                mm = markov_matrix(bytes_list)

                # 生成滑动窗口为256个字节的香农熵
                em = entropy_map(bytes_list, 256)

                c = Image.new("RGB", (dim, dim))
                id = ImageDraw.Draw(c)

                for i in range(dim):
                    for j in range(dim):
                        # 重复填充
                        index = arr[i][j] % len(bytes_list)
                        index1 = arr[i][j] % len(em)
                        id.point((i, j), (mm[i][j], bytes_list[index], em[index1]))

                c.save(
                    os.path.join("D:\\academy\AcaUni\实验班\网安分析实践\BYTES-DATABASE\\three_chan_hil", subDir, f"{file}.png"))
                num = num + 1
                print(num)


def bodmas_generate():
    # 初始化
    file_list = os.listdir("C:\\Users\\86183\\Desktop\\malware\\benign(1)")
    arr = np.load("./hilbert.npy")
    n = 8
    dim = 2 ** n
    num = 0
    # 遍历生成
    for file in file_list:
        num = num + 1
        if os.path.exists(f"C:\\Users\\86183\\Desktop\\malware\\benign_img\\{file}.png"):
            print(num, file + '.png exists')
            continue

        bytes_list = b''
        # 读文件
        with open(os.path.join(
                "C:\\Users\\86183\\Desktop\\malware\\benign(1)", file),
                mode="r") as f:
            content = f.read()
            if len(content) == 0:
                print(num, f'{file} is empty')
                continue
            while len(content) < 65536 * 2:
                content += content

            content = content[:65536 * 2]
            bytes_list = bytes.fromhex(content)
            # 生成基于2-gram的马尔科夫概率矩阵
            mm = markov_matrix(bytes_list)

            # 生成滑动窗口为256个字节的香农熵
            em = entropy_map(bytes_list, 256)

            # print(len(em), len(bytes_list))

            # 绘制RGB图像
            # img = {r: markov, g: origin, b: entropy}
            c = Image.new("RGB", (dim, dim))
            draw = ImageDraw.Draw(c)

            for i in range(dim):
                for j in range(dim):
                    # 重复填充
                    index = arr[i][j] % len(bytes_list)
                    index1 = arr[i][j] % len(em)
                    draw.point((i, j), (mm[i][j], bytes_list[index], em[index1]))

            c.save(f"C:\\Users\\86183\\Desktop\\malware\\benign_img\\{file}.png")
            print(num)


# generate1()
bodmas_generate()
