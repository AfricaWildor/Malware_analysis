import array
import math

import numpy as np
from PIL import Image, ImageDraw

'''
	对照组： 
		origin_order_gray + hil_gray + markov
'''


# 生成基于2-gram的马尔科夫概率矩阵
def markov_matrix(file_bytes):
	buffer = array.array('B', file_bytes)

	array1 = np.zeros((256, 256), dtype=int)
	for i in range(len(buffer) - 2):
		j = i + 1
		array1[buffer[i]][buffer[j]] += 1

	turn_array = np.zeros(256, dtype=int)
	for i in range(256):
		for j in range(256):
			turn_array[i] += array1[i][j]

	array2 = np.zeros((256, 256), dtype=int)
	for i in range(256):
		for j in range(256):
			if turn_array[i] != 0:
				array2[i][j] = math.ceil((array1[i][j] / turn_array[i]) * 255) * 32

	return array2


hil_mat = np.load("./hilbert.npy")

bytes_list = b''
line = 0
# 读文件
with open("./sample/0A32eTdBKayjCWhZqDOQ.bytes", mode="r") as f:
	for l in f:
		if l.find("?") >= 0:
			continue
		str_list = l.split(" ")[1:]
		b = bytes.fromhex("".join(str_list))
		bytes_list += b
		line = line + 1
		if line == 4096:
			break

# 生成基于2-gram的马尔科夫概率矩阵
mm = markov_matrix(bytes_list)

dim = 256
c = Image.new("RGB", (dim, dim))
draw = ImageDraw.Draw(c)

for i in range(dim):
	for j in range(dim):
		# 重复填充
		index = hil_mat[i][j] % len(bytes_list)
		index1 = (j * dim + i) % len(bytes_list)
		draw.point((i, j), (mm[i][j], bytes_list[index], bytes_list[index1]))
		# draw.point((i, j), (mm[i][j], bytes_list[index1], bytes_list[index]))
		# draw.point((i, j), (mm[i][j], bytes_list[index1], 0))
		# draw.point((i, j), (mm[i][j], 0, bytes_list[index]))

c.save("./contrast.png")
