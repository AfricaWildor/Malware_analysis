# -*- codeing = utf-8 -*-

import os
import re
import zipfile  # 用于对zip压缩包的操作
from zipfile import ZipFile
import pyzipper
from pyzipper import AESZipFile
import pefile
from capstone import *
# import pydasm

def bytes2hexStr(bytes):
	hexStr = bytes.hex()
	return hexStr




def text_extract(filebytes):
		pe = pefile.PE(data=filebytes)

		# for section in pe.sections:
		# 	print(section)

		for section in pe.sections:
			if section.Name.startswith(b'.text\x00'):
				# print(section)
				return section.get_data()


def bytes2bytesFile(filebytes,filename):
	if filebytes is None:
		print('[!] Error,no .text found')
		return
	# if not os.path.exists('./bytesfile'):  # 是否存在这个文件夹
	# 	os.makedirs('./bytesfile')  # 如果没有 创建一个
	hexStr = bytes2hexStr(filebytes)
	# print(hexStr)
	# 每2个为一组
	hexlist = re.findall(r'.{2}', hexStr)
	# print(hexlist)
	content = ''
	length = len(hexlist)
	flag = 1
	for hex in range(0, length):
		if flag == 16:
			flag = 0
			content += f'{hexlist[hex]}\r\n'
		else:
			content += f'{hexlist[hex]} '
		if hex == length - 1:
			content += f'{hexlist[hex]}'
		flag += 1
	# print(f'Convert {filename} to bytes')
	# print(content)
	contentbytes = bytes(content, 'utf-8')
	bytes_filepath = filename.split('.zip')[0] + '.bytes'

	with open(bytes_filepath, 'wb') as file:
		file.write(contentbytes)
		print(f'write in {bytes_filepath}')


def bytes2AssemblyCode(filebytes):
	code=filebytes
	print(filebytes)
	mode=Cs(CS_ARCH_X86, CS_MODE_32)
	for i in mode.disasm(code, 0x1000):
		print("0x%x:\t%s\t%s" % (i.address, i.mnemonic, i.op_str))


	# ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
	# ep_ava = ep + pe.OPTIONAL_HEADER.ImageBase
	# data = pe.get_memory_mapped_image()[ep:ep + 100]
	# offset = 0
	# while offset < len(data):
	# 	i = pydasm.get_instruction(data[offset:], pydasm.MODE_32)
	# 	print(pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava + offset))

def get_main_code_section(sections, base_of_code):
	addresses = []
	# get addresses of all sections
	for section in sections:
		addresses.append(section.VirtualAddress)

	# if the address of section corresponds to the first instruction then
	# this section should be the main code section
	if base_of_code in addresses:
		return sections[addresses.index(base_of_code)]
	# otherwise, sort addresses and look for the interval to which the base of code
	# belongs
	else:
		addresses.append(base_of_code)
		addresses.sort()
		if addresses.index(base_of_code) != 0:
			return sections[addresses.index(base_of_code) - 1]
		else:
			# this means we failed to locate it
			return None

def fine_disassemble(filepath):
	#get main code section
	exe=pefile.PE(filepath)
	main_code = get_main_code_section(exe.sections, exe.OPTIONAL_HEADER.BaseOfCode)
	#define architecutre of the machine
	md = Cs(CS_ARCH_X86, CS_MODE_32)
	md.detail = True
	last_address = 0
	last_size = 0
	#Beginning of code section
	begin = main_code.PointerToRawData
	#the end of the first continuous bloc of code
	end = begin+main_code.SizeOfRawData
	while True:
		#parse code section and disassemble it
		data = exe.get_memory_mapped_image()[begin:end]
		for i in md.disasm(data, begin):
			print(i)
			last_address = int(i.address)
			last_size = i.size
		#sometimes you need to skip some bytes
		begin = max(int(last_address),begin)+last_size+1
		if begin >= end:
			print("out")
			break

def zip2text(filepath):
	if pyzipper.is_zipfile(filepath):
		file = AESZipFile(filepath)
		filelist = file.namelist()
		print(filelist)
		filename=filelist[0]#解压文件名
		pwd=b'infected'
		filebytes=file.read(filename,pwd)
		textbytes=text_extract(filebytes)
		file.close()
		bytes2bytesFile(textbytes,filepath)
		# 是否删除原zip文件
		os.remove(filepath)



def zip2anything(filepath):
	if pyzipper.is_zipfile(filepath):
		file = AESZipFile(filepath)
		filelist = file.namelist()
		print(filelist)
		filename=filelist[0]#解压文件名
		pwd=b'infected'
		filebytes=file.read(filename,pwd)
		file.close()
		bytes2AssemblyCode(filebytes)
		# 是否删除原zip文件
		# os.remove(filepath)


if __name__ == '__main__':
	PEfile_Path = "overflow_exe.exe"
	fine_disassemble(PEfile_Path)
	# with open(PEfile_Path, 'rb') as file:
	# 	filebytes=file.read()


