import array
import math

import cv2
import numpy as np
from PIL import ImageDraw
from PIL import Image

hil_mat = np.load('./hilbert.npy')

# 生成指定大小滑动窗口的香农熵
def entropy_map(file_bytes, sliding_window):
	d = int(len(file_bytes) / sliding_window)
	m = []
	for i in range(d):
		base = i * sliding_window
		window = file_bytes[base:base + sliding_window]
		count = {}  # 空字典
		for j in window:
			count[j] = count.get(j, 0) + (1 / len(window))
		entro = []
		for a in count.values():
			entro.append(a)
		result = 0
		for x in entro:
			result += (-x) * math.log(x, 2)
		for j in range(sliding_window):
			m.append(int(result * 32))
	return m


# 生成基于2-gram的马尔科夫概率矩阵
def markov_matrix(file_bytes):
	buffer = array.array('B', file_bytes)

	array1 = np.zeros((256, 256), dtype=int)
	for i in range(len(buffer) - 2):
		j = i + 1
		array1[buffer[i]][buffer[j]] += 1

	turn_array = np.zeros(256, dtype=int)
	for i in range(256):
		for j in range(256):
			turn_array[i] += array1[i][j]

	array2 = np.zeros((256, 256), dtype=int)
	for i in range(256):
		for j in range(256):
			if turn_array[i] != 0:
				array2[i][j] = math.ceil((array1[i][j] / turn_array[i]) * 255) * 2

	m = array2.astype('uint8')
	kernel = np.ones((9, 9), np.uint8)
	mm = cv2.dilate(m, kernel)
	return mm

def generate(raw, path):

	while len(raw) < 65536:
		raw += raw
	raw = raw[:65536]

	em = entropy_map(raw, 256)
	mm = markov_matrix(raw)

	c = Image.new("RGB", (256, 256))
	draw = ImageDraw.Draw(c)
	for i in range(256):
		for j in range(256):
			# 重复填充
			index = hil_mat[i][j] % len(raw)
			index1 = hil_mat[i][j] % len(em)
			draw.point((i, j), (mm[i][j], raw[index], em[index1]))

	c.save(path)