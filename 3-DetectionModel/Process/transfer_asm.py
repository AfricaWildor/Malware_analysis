import pefile
from capstone import *

def exe2asm_code(r):
	pe = pefile.PE(data=r.raw)
	# pe = pefile.PE(filebytes)

	text_section = r.text_section
	# if there's no .text,return
	if text_section is None:
		print('[!] Error, no .text found')
		return ''

	asm_mode = r.asm_mode
	# define the disasm mode
	md = Cs(CS_ARCH_X86, asm_mode)
	md.detail = True
	last_address = 0
	last_size = 0
	# Beginning of code section
	begin = text_section.PointerToRawData
	# the end of the code section
	end = begin + text_section.SizeOfRawData
	# print(hex(begin),hex(end))
	asm_code = ''  # store the op
	# the second arg just give the address offset, no influence to the op
	while True:
		# parse code section and disassemble it
		data = pe.get_memory_mapped_image()[begin:end]
		for i in md.disasm(data, begin):
			asm_code = " ".join([asm_code, f'{i.mnemonic}'])
			last_address = int(i.address)
			last_size = i.size
		# disasm 一次反汇编有个数限制，故需循环多次反汇编，每次的起始翻译地址需循环变动
		begin = max(int(last_address), begin) + last_size + 1
		# 若起始地址大于等于结束地址，则代码段全部翻译
		if begin >= end:
			break
	return asm_code